<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content=""/>



    <meta name="description" content="集合的继承关系图

从图中可以看出，集合的根节点是 Collection，而 Collection 下又提供了两大常用集合，分别是
- List：使用最多的有序集合，提供方便的新增、修改、删除的操作；
- Set：集合不允许有重复的元素，在许多需要保证元素唯一性的场景中使用

集合使用Vect..."/>


<meta name="Robots" content="all">


    <title>Hexo | 集合</title>


<link rel="icon" href="/images/harry.ico">

<link rel="stylesheet" href="/css/font-awesome.min.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/style.css">


<script src="/js/highlight.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/"
                
                >Home</a>
            
                <a class="nav-item" href="/resume"
                
                >Resume</a>
            
                <a class="nav-item" href="/mood"
                
                   target="_blank"
                
                >Mood</a>
            
                <a class="nav-item" href="/amusement/tetris"
                
                   target="_blank"
                
                >Amusement</a>
            
                <a class="nav-item" href="/about"
                
                >About</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                <article class="box post">
    <div class="post-title align-center detail-title">集合</div>
    <div class="post-meta align-center">
        
        <i class="fa fa-calendar"></i> <time>2020-11-22</time>
        <span class="dotted">|</span>
        <i class="fa fa-user"></i> 
        
    </div>

    <div class="post-content">
        <h2 id="集合的继承关系图"><a href="#集合的继承关系图" class="headerlink" title="集合的继承关系图"></a>集合的继承关系图</h2><a id="more"></a>
<img src="/2020/11/22/java-12/01.png" class="img-stand">
从图中可以看出，集合的根节点是 Collection，而 Collection 下又提供了两大常用集合，分别是
- List：使用最多的有序集合，提供方便的新增、修改、删除的操作；
- Set：集合不允许有重复的元素，在许多需要保证元素唯一性的场景中使用

<h2 id="集合使用"><a href="#集合使用" class="headerlink" title="集合使用"></a>集合使用</h2><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>Vector 是 Java 早期提供的线程安全的有序集合，<strong>如果不需要线程安全，不建议使用此集合</strong>，毕竟同步是有线程开销的</p>
<pre><code>//[dog]
Vector vector = new Vector();
vector.add(&quot;dog&quot;);
vector.add(&quot;cat&quot;);
vector.remove(&quot;cat&quot;);
System.out.println(vector);</code></pre><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>是最常见的<strong>非线程安全的有序集合，因为内部是数组存储的，所以随机访问效率很高，但非尾部的插入和删除性能较低</strong>，如果在中间插入元素，之后的所有元素都要后移。ArrayList的使用与 Vector 类似</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><strong>LinkedList 是使用双向链表数据结构实现的，因此增加和删除效率比较高，而随机访问效率较差。</strong><br>LinkedList 除了包含以上两个类的操作方法之外，还新增了几个操作方法，如 offer() 、peek() 等</p>
<pre><code>LinkedList linkedList = new LinkedList();
// 添加元素
linkedList.offer(&quot;bird&quot;);
linkedList.push(&quot;cat&quot;);
linkedList.push(&quot;dog&quot;);
// 获取第一个元素
System.out.println(linkedList.peek());
// 获取第一个元素，并删除此元素
System.out.println(linkedList.poll());
System.out.println(linkedList);</code></pre><p>程序的执行结果</p>
<pre><code>dog
dog
[cat, bird]</code></pre><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>HashSet 是一个没有重复元素的集合。虽然它是 Set 集合的子类，实际却为 HashMap 的实例</p>
<pre><code>public HashSet() {
    map = new HashMap&lt;&gt;();
}</code></pre><p><strong>因此 HashSet 是无序集合，没有办法保证元素的顺序性，HashSet 默认容量为 16，每次扩充 0.75 倍</strong>，HashSet 的使用与 Vector 类似。</p>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet 集合实现了自动排序，也就是说 TreeSet 会把你插入数据进行自动排序。</p>
<pre><code>TreeSet treeSet = new TreeSet();
treeSet.add(&quot;dog&quot;);
treeSet.add(&quot;camel&quot;);
treeSet.add(&quot;cat&quot;);
treeSet.add(&quot;ant&quot;);
System.out.println(treeSet);</code></pre><p>程序执行结果：[ant, camel, cat, dog]</p>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><p><strong>LinkedHashSet 是按照元素的 hashCode值来决定元素的存储位置，但同时又使用链表来维护元素的次序，这样使得它看起来像是按照插入顺序保存的</strong>，LinkedHashSet 的使用与 Vector 类似</p>
<h4 id="集合与数组"><a href="#集合与数组" class="headerlink" title="集合与数组"></a>集合与数组</h4><p>集合和数组的转换可使用 toArray() 和 Arrays.asList() 来实现</p>
<pre><code>List&lt;String&gt; list = new ArrayList();
list.add(&quot;cat&quot;);
list.add(&quot;dog&quot;);
// 集合转数组
String[] arr = list.toArray(new String[list.size()]);
// 数组转集合
List&lt;String&gt; list2 = Arrays.asList(arr);</code></pre><h4 id="集合排序"><a href="#集合排序" class="headerlink" title="集合排序"></a>集合排序</h4><ul>
<li><p>Comparable<br>Comparable 位于 java.lang 包下，是一个排序接口，也就是说如果一个类实现了 Comparable 接口，就意味着该类有了排序功能。Comparable 接口只包含了一个函数，定义如下</p>
<pre><code>package java.lang;
import java.util.*;
public interface Comparable {
public int compareTo(T o);
}</code></pre></li>
</ul>
<p>使用</p>
<pre><code>class ComparableTest {
    public static void main(String[] args) {
        Dog[] dogs = new Dog[]{
                new Dog(&quot;老旺财&quot;, 10),
                new Dog(&quot;小旺财&quot;, 3),
                new Dog(&quot;二旺财&quot;, 5),
        };
        // Comparable 排序
        Arrays.sort(dogs);
        for (Dog d : dogs) {
            System.out.println(d.getName() + &quot;：&quot; + d.getAge());
        }
    }
}
class Dog implements Comparable&lt;Dog&gt; {
    private String name;
    private int age;
    @Override
    public int compareTo(Dog o) {
        return age - o.age;
    }
    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }
}</code></pre><ul>
<li><p>Comparator<br>Comparator 是一个外部比较器，位于 java.util 包下，之所以说 Comparator 是一个外部比较器，是因为它无需在比较类中实现<br>Comparator 接口，而是要新创建一个比较器类来进行比较和排序。<br>Comparator 接口包含的主要方法为 compare()，定义如下：</p>
<pre><code>public interface Comparator&lt;T&gt; {
int compare(T o1, T o2);
}</code></pre><p>Comparator 使用示例</p>
<pre><code>class ComparatorTest {
    public static void main(String[] args) {
        Dog[] dogs = new Dog[]{
                new Dog(&quot;老旺财&quot;, 10),
                new Dog(&quot;小旺财&quot;, 3),
                new Dog(&quot;二旺财&quot;, 5),
        };
        // Comparator 排序
        Arrays.sort(dogs,new DogComparator());
        for (Dog d : dogs) {
            System.out.println(d.getName() + &quot;：&quot; + d.getAge());
        }
    }
}
class DogComparator implements Comparator&lt;Dog&gt; {
    @Override
    public int compare(Dog o1, Dog o2) {
        return o1.getAge() - o2.getAge();
    }
}
class Dog {
    private String name;
    private int age;
    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }
}</code></pre></li>
</ul>
<h4 id="List-和-Set-有什么区别"><a href="#List-和-Set-有什么区别" class="headerlink" title="List 和 Set 有什么区别"></a>List 和 Set 有什么区别</h4><ul>
<li>List 允许有多个 null 值，Set 只允许有一个 null 值</li>
<li>List 允许有重复元素，Set 不允许有重复元素</li>
<li>ist 可以保证每个元素的存储顺序，Set 无法保证元素的存储顺序</li>
</ul>
<h4 id="哪种集合可以实现自动排序"><a href="#哪种集合可以实现自动排序" class="headerlink" title="哪种集合可以实现自动排序"></a>哪种集合可以实现自动排序</h4><p>TreeSet 集合实现了元素的自动排序，也就是说无需任何操作，即可实现元素的自动排序功能</p>
<h4 id="Vector-和-ArrayList-初始化大小和容量扩充有什么区别"><a href="#Vector-和-ArrayList-初始化大小和容量扩充有什么区别" class="headerlink" title="Vector 和 ArrayList 初始化大小和容量扩充有什么区别"></a>Vector 和 ArrayList 初始化大小和容量扩充有什么区别</h4><p>Vector 和 ArrayList 的默认容量都为 10</p>
<ul>
<li>Vector 容量扩充默认增加 1 倍</li>
<li>ArrayList 容量扩充默认增加大概 0.5 倍</li>
</ul>
<h4 id="Vector、ArrayList、LinkedList-有什么区别"><a href="#Vector、ArrayList、LinkedList-有什么区别" class="headerlink" title="Vector、ArrayList、LinkedList 有什么区别"></a>Vector、ArrayList、LinkedList 有什么区别</h4><p>这三者都是 List 的子类，因此功能比较相似，比如增加和删除操作、查找元素等，但在性能、线程安全等方面表现却又不相同，差异如下</p>
<ul>
<li>Vector 是 Java 早期提供的动态数组，它使用 synchronized 来保证线程安全，如果非线程安全需要不建议使用，毕竟线程同步是有性能开销的</li>
<li>ArrayList 是最常用的动态数组，本身并不是线程安全的，因此性能要好很多，与 Vector 类似，它也是动态调整容量的，只不过 Vector 扩容时会增加 1 倍，而 ArrayList 会增加 50%</li>
<li>LinkedList 是双向链表集合，因此它不需要像上面两种那样调整容量，它也是非线程安全的集合</li>
</ul>
<h4 id="Collection-和-Collections-有什么区别"><a href="#Collection-和-Collections-有什么区别" class="headerlink" title="Collection 和 Collections 有什么区别"></a>Collection 和 Collections 有什么区别</h4><ul>
<li>Collection 是集合类的上级接口，继承它的主要有 List 和 Set</li>
<li>Collections 是针对集合类的一个帮助类，它提供了一些列的静态方法实现，如 Collections.sort() 排序、Collections.reverse() 逆序等</li>
</ul>
<h4 id="LinkedHashSet-如何保证有序和唯一性"><a href="#LinkedHashSet-如何保证有序和唯一性" class="headerlink" title="LinkedHashSet 如何保证有序和唯一性"></a>LinkedHashSet 如何保证有序和唯一性</h4><p><strong>LinkedHashSet 底层数据结构由哈希表和链表组成，链表保证了元素的有序即存储和取出一致，哈希表保证了元素的唯一性</strong></p>
<h4 id="HashSet-是如何保证数据不可重复的"><a href="#HashSet-是如何保证数据不可重复的" class="headerlink" title="HashSet 是如何保证数据不可重复的"></a>HashSet 是如何保证数据不可重复的</h4><p>HashSet 的底层其实就是 HashMap，只不过 HashSet 实现了 Set 接口并且把数据作为 K 值，而 V值一直使用一个相同的虚值来保存，我们可以看到源码</p>
<pre><code>public boolean add(E e) {
    return map.put(e, PRESENT)==null;// 调用 HashMap 的 put 方法,PRESENT 是一个至始至终都相同的虚值
}</code></pre><p>由于 HashMap 的 K 值本身就不允许重复，并且在 HashMap 中如果 K/V 相同时，会用新的 V 覆盖掉旧的 V，然后返回旧的 V，那么在<br>HashSet 中执行这一句话始终会返回一个 false，导致插入失败，这样就保证了数据的不可重复性</p>
<h4 id="如何用程序实现后进先出的栈结构"><a href="#如何用程序实现后进先出的栈结构" class="headerlink" title="如何用程序实现后进先出的栈结构"></a>如何用程序实现后进先出的栈结构</h4><pre><code>Stack stack = new Stack();
stack.push(&quot;a&quot;);
stack.push(&quot;b&quot;);
stack.push(&quot;c&quot;);
for (int i = 0; i &lt; 3; i++) {
    // 移除并返回栈顶元素
    System.out.print(stack.pop() + &quot; &quot;);
}</code></pre><h4 id="LinkedList-中的-peek-和-poll-有什么区别"><a href="#LinkedList-中的-peek-和-poll-有什么区别" class="headerlink" title="LinkedList 中的 peek() 和 poll() 有什么区别"></a>LinkedList 中的 peek() 和 poll() 有什么区别</h4><p>peek() 方法返回第一个元素，但不删除当前元素，当元素不存在时返回 null；poll() 方法返回第一个元素并删除此元素，当元素不存在时返回<br>null</p>
<h4 id="Comparable-和-Comparator-有哪些区别"><a href="#Comparable-和-Comparator-有哪些区别" class="headerlink" title="Comparable 和 Comparator 有哪些区别"></a>Comparable 和 Comparator 有哪些区别</h4><ul>
<li>Comparable 位于 java.lang 包下，而 Comparator 位于 java.util 包下；</li>
<li>Comparable 在排序类的内部实现，而 Comparator 在排序类的外部实现</li>
<li>Comparable 需要重写 CompareTo() 方法，而 Comparator 需要重写 Compare() 方法</li>
<li>Comparator 在类的外部实现，更加灵活和方便</li>
</ul>

    </div>
</article>
            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/harry.jpg" alt="head-sculpture" /></p>
        <p class="name">
            呵 呵 哒
        </p>
        <p class="slogan">铁打的肩膀，才能抗得起光芒</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">Recent</div>
    <ul class="item-box">
        
            
                <li><a href="/2020/11/22/java-13/">Map</a></li>
            
        
            
                <li><a href="/2020/11/22/java-12/">集合</a></li>
            
        
            
                <li><a href="/2020/11/22/java-11/">克隆和序列化</a></li>
            
        
            
                <li><a href="/2020/11/07/java-10/">抽象类和接口</a></li>
            
        
            
                <li><a href="/2020/11/06/java-09/">内部类和枚举类</a></li>
            
        
            
                <li><a href="/2020/11/04/java-08/">类与 Object 的应用</a></li>
            
        
            
                <li><a href="/2020/11/04/java-07/">数组和排序算法</a></li>
            
        
            
                <li><a href="/2020/11/03/java-06/">java时间类</a></li>
            
        
    </ul>
</div>

    
        
    
        
  <div class="box widget">
    <div class="title">Archives</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">2020-11</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">2020-10</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">2020-06</a><span class="archive-list-count">1</span></li></ul>
  </div>

    
        
    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
            <span class="dotted">|</span>
            <span><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener">浙ICP备18016660号-1</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>